name: settle
on:
  schedule: [{ cron: "50 4 * * *" }]   # 04:50 UTC ≈ 06:50 DK
  workflow_dispatch:
jobs:
  run:
    runs-on: ubuntu-latest
    env:
      POSTGRES_URL: ${{ secrets.POSTGRES_URL }}
      APIFOOTBALL_KEY: ${{ secrets.APIFOOTBALL_KEY }}
      TZ: Europe/Copenhagen
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: "3.11" }
      - run: |
          python -m pip install --upgrade pip
          python -m pip install "sqlalchemy>=2" "psycopg[binary]" pandas numpy pyarrow joblib requests
      - name: API-Football sanity
        run: |
          python - <<'PY'
          import os, requests
          key = os.environ.get("APIFOOTBALL_KEY", "")
          print("APIFOOTBALL_KEY length:", len(key))
          if not key:
            raise SystemExit("APIFOOTBALL_KEY is empty. Add it as a GitHub Actions secret.")
          headers = {"x-apisports-key": key}
          try:
              r = requests.get("https://v3.football.api-sports.io/status", headers=headers, timeout=20)
              print("/status code:", r.status_code)
              print("/status body (first 800 chars):", r.text[:800])
              if r.status_code == 403:
                  raise SystemExit("403 from /status — check that the key is correct and not quoted.")
          except Exception as e:
              raise SystemExit(f"Sanity call failed: {e}")
          PY
      - name: Upsert outcomes (last 3 days)
        run: |
          python - <<'PY'
          import os, requests, datetime as dt
          from datetime import datetime, timezone
          from sqlalchemy import create_engine, text
          e=create_engine(os.environ["POSTGRES_URL"], pool_pre_ping=True)
          headers={"x-apisports-key": os.environ["APIFOOTBALL_KEY"]}
          UPS=text("""
            INSERT INTO outcomes (fixture_id, league_id, season, kick_off, result, goals_h, goals_a, updated_at)
            VALUES (:fixture_id,:league_id,:season,:kick_off,:result,:goals_h,:goals_a, now())
            ON CONFLICT (fixture_id) DO UPDATE
            SET result=EXCLUDED.result, goals_h=EXCLUDED.goals_h, goals_a=EXCLUDED.goals_a, updated_at=now();
          """)
          def res(h,a): return None if (h is None or a is None) else ("H" if h>a else ("A" if a>h else "D"))
          def upsert(date):
              r = requests.get(
                  "https://v3.football.api-sports.io/fixtures",
                  params={"date": date, "timezone": "UTC"},
                  headers=headers,
                  timeout=30,
              )
              if r.status_code == 403:
                  print(f"[fixtures] 403 Forbidden for date={date}. Body (first 400): {r.text[:400]}")
                  raise SystemExit(0)
              if r.status_code == 429:
                  print("[fixtures] 429 rate limited — sleeping 10s and retrying once…")
                  import time
                  time.sleep(10)
                  r = requests.get(
                      "https://v3.football.api-sports.io/fixtures",
                      params={"date": date, "timezone": "UTC"},
                      headers=headers,
                      timeout=30,
                  )
              r.raise_for_status()
              resp=r.json().get("response",[])
              with e.begin() as c:
                  for it in resp:
                      f,L,G=it["fixture"],it["league"],it.get("goals") or {}
                      ts=f.get("timestamp")
                      kick=datetime.fromtimestamp(ts, timezone.utc).isoformat().replace("+00:00","Z") if ts else None
                      st=(f.get("status") or {}).get("short")
                      if st in {"FT","AET","PEN"} and G.get("home") is not None:
                          c.execute(UPS, {
                              "fixture_id": f["id"], "league_id": L.get("id"), "season": L.get("season"),
                              "kick_off": kick, "result": res(G["home"], G["away"]),
                              "goals_h": G["home"], "goals_a": G["away"]
                          })
          today=dt.date.today()
          for d in [today, today-dt.timedelta(days=1), today-dt.timedelta(days=2)]:
              upsert(d.isoformat())
          # Fill closing odds from snapshots
          with e.begin() as c:
            c.execute(text("""
              WITH last_preko AS (
                SELECT s.fixture_id, MAX(s.fetched_at_utc) AS ts
                FROM odds_snapshots s
                JOIN outcomes o ON o.fixture_id = s.fixture_id
                WHERE s.market='1X2' AND o.kick_off IS NOT NULL AND s.fetched_at_utc <= o.kick_off
                GROUP BY s.fixture_id
              ),
              sel AS (
                SELECT s.fixture_id, s.selection, s.price
                FROM odds_snapshots s JOIN last_preko lp
                  ON lp.fixture_id=s.fixture_id AND lp.ts=s.fetched_at_utc
                WHERE s.market='1X2'
              ),
              pivot AS (
                SELECT fixture_id,
                       MAX(CASE WHEN selection='H' THEN price END) AS cl_h,
                       MAX(CASE WHEN selection='D' THEN price END) AS cl_d,
                       MAX(CASE WHEN selection='A' THEN price END) AS cl_a
                FROM sel GROUP BY fixture_id
              )
              UPDATE outcomes o
              SET closing_odds_h = COALESCE(p.cl_h, o.closing_odds_h),
                  closing_odds_d = COALESCE(p.cl_d, o.closing_odds_d),
                  closing_odds_a = COALESCE(p.cl_a, o.closing_odds_a),
                  updated_at = now()
              FROM pivot p
              WHERE o.fixture_id = p.fixture_id;
            """))
          PY
      - name: Harvest match statistics (last 3 days)
        run: |
          python - <<'PY'
          import os, requests, datetime as dt
          from datetime import datetime, timezone
          from sqlalchemy import create_engine, text

          e = create_engine(os.environ["POSTGRES_URL"], pool_pre_ping=True)
          headers = {"x-apisports-key": os.environ["APIFOOTBALL_KEY"]}

          with e.connect() as c:
              fids = [r[0] for r in c.execute(text("""
                SELECT o.fixture_id
                FROM outcomes o
                WHERE o.result IS NOT NULL
                  AND o.updated_at >= now() - interval '3 days'
                  AND (o.home_shots_on_goal IS NULL OR o.away_shots_on_goal IS NULL
                       OR o.home_ball_possession IS NULL OR o.away_ball_possession IS NULL
                       OR o.home_expected_goals IS NULL OR o.away_expected_goals IS NULL)
                LIMIT 500
              """)).fetchall()]

          UPS = text("""
            UPDATE outcomes SET
              home_shots_on_goal = COALESCE(:h_sog, home_shots_on_goal),
              away_shots_on_goal = COALESCE(:a_sog, away_shots_on_goal),
              home_ball_possession = COALESCE(:h_poss, home_ball_possession),
              away_ball_possession = COALESCE(:a_poss, away_ball_possession),
              home_expected_goals = COALESCE(:h_xg, home_expected_goals),
              away_expected_goals = COALESCE(:a_xg, away_expected_goals),
              updated_at = now()
            WHERE fixture_id = :fid
          """)

          def to_num(x):
              if x is None: return None
              if isinstance(x,(int,float)): return float(x)
              s=str(x).strip()
              if s.endswith("%"):
                  try: return float(s[:-1])
                  except: return None
              try: return float(s)
              except: return None

          updated = 0
          for fid in fids:
              try:
                  r = requests.get("https://v3.football.api-sports.io/fixtures/statistics",
                                   params={"fixture": int(fid)}, headers=headers, timeout=30)
                  if r.status_code == 404:
                      continue
                  r.raise_for_status()
                  resp = r.json().get("response", [])
                  teams = {}
                  for team_block in resp:
                      tname = (team_block.get("team") or {}).get("name","")
                      vals = {}
                      for s in team_block.get("statistics") or []:
                          typ = (s.get("type") or "").strip()
                          vals[typ] = s.get("value")
                      teams[tname] = vals

                  # Map home/away via earliest pick row (fallback to first two names)
                  with e.connect() as c2:
                      row = c2.execute(text("SELECT home, away FROM picks WHERE fixture_id=:fid ORDER BY created_at ASC LIMIT 1"), {"fid": fid}).fetchone()
                  hname, aname = (row[0], row[1]) if row else (None, None)
                  H = teams.get(hname) or {}
                  A = teams.get(aname) or {}
                  if not H or not A:
                      names = list(teams.keys())
                      if len(names) >= 2:
                          H = teams.get(names[0], {})
                          A = teams.get(names[1], {})

                  data = {
                      "fid": fid,
                      "h_sog": to_num(H.get("Shots on Goal")),
                      "a_sog": to_num(A.get("Shots on Goal")),
                      "h_poss": to_num(H.get("Ball Possession")),
                      "a_poss": to_num(A.get("Ball Possession")),
                      "h_xg": to_num(H.get("Expected Goals")),
                      "a_xg": to_num(A.get("Expected Goals")),
                  }
                  with e.begin() as c3:
                      c3.execute(UPS, data)
                  updated += 1
              except Exception as ex:
                  print(f"[stats] fixture={fid}: {ex}")

          print(f"✅ stats updated rows: {updated}")
          PY
      - name: Settle picks
        run: |
          python scripts/settle_picks.py
